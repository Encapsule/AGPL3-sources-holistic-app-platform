// @encapsule/holistic/SOURCES/LIB/holarchy/opc/filters/iospecs/opc-method-constructor-output-spec.js

module.exports = {
    ____types: "jsObject",

    // Generated by opc constructor filter using conditional algorithm.
    id: {
        ____label: "OCP System Version-Independent ID",
        ____description: "Unique developer-assigned Version-Independent Identifier (VIID) that does not changed. Used to grossly discriminate different OPC systems that may be used in one runtime. And, in logs.",
        ____accept: "jsString"
    },

    // Generated by opc constructor filter using IRUT-encoded v4 UUID.
    iid: {
        ____label: "OCP System Instance ID",
        ____description: "Random v4 UUID-derived IRUT used to identify this specific OPC instance.",
        ____accept: "jsString"
    },

    // Generated by opc constructor filter using conditional algorithm.
    name: {
        ____label: "OCP System Name",
        ____description: "Developer-defined short name assigned to this OPC system model.",
        ____accept: "jsString"
    },

    // Generated by opc constructor filter using conditional algorithm.
    description: {
        ____label: "OCP System Description",
        ____description: "Developer-defined short descripion of the function and/or role of this OPC configuration.",
        ____accept: "jsString"
    },

    // Generated by opc constructor filter by flattening dev-specified opm sets.
    opmMap: {
        ____label: "OPM Map",
        ____description: "A flattend map of the OPM instances passed into the OPC constructor method.",
        ____types: "jsObject",
        ____asMap: true,
        opmId: { // ObservableProcessModel ES6 class instance reference
            ____label: "OPM Class Instance Reference",
            ____description: "Reference to an OPM class instance passed to the OPC constructor method.",
            ____accept: "jsObject" // We do not validate ES6 classes w/filter. They're designed to be valid by construction. Or, in zombie state.
        }
    },

    // Generated by opc constructor filter by analyzing the dev-specified ocd template spec's opm bindings and the opm currently registered in opmMap.
    opmiSpecPaths: {
        ____label: "OPMI Spec Paths",
        ____description: "Array of abstract OPM to OCD data namespace binding descriptors created by the OPC constructor. There will be one element per dev-defined OCD spec namespace w/registered OPM binding appdsl annotation.",
        ____types: "jsArray",
        opmiBindingDescriptor: {
            ____label: "OPMI Binding Descriptor",
            ____description: "Descriptor object that relates a developer-defined OCD namespace path with its registered OPM instance.",
            ____types: "jsObject",
            specPath: {
                ____label: "OCD Spec Path",
                ____description: "Filter-style dot-delimited path to the OCD spec namespace with ____appdsl: { opm: IRUT } } annotation.",
                ____accept: "jsString"
            },
            opmiRef: { // ObservableProcessModel ES6 class instance reference
                ____label: "OPM Class Instance Reference",
                ____description: "Reference to an OPM class instance passed to the OPC constructor method.",
                ____accept: "jsObject" // We do not validate ES6 classes w/filter. They're designed to be valid by construction. Or, in zombie state.
            }
        }
    },

    // Copied in opc contructor filter after verification of dev-specified ocd template spec.
    ocdTemplateSpec: {
        ____label: "OCD Template Filter Spec",
        ____description: "Copy of the developer-defined OCD template spec passed to OCP constructor.",
        ____accept: "jsObject" // You can't filter a filter spec w/a filter spec. But you can accept an opaque object and validate the incoming spec by building a filter which is what we do here.
    },

    // Generated by opc constructor by merging bound namespace specs in dev-specified ocd template spec w/the corresponding opm data spec.
    // The significance of this little trick is quite profound I think. It will require some more thought to fully exploit this mechanism to its full affect.
    // NOTE: If you find yourself dreaming up clever ways to build your OCD template or OPM data specs please let me know...
    // I have planned another holistic platform lib called @encapsule/holarchy-aspects-kit intended to address many higher-level
    // programming model conerns that will become apparent when people start applying @encapsule/holarchy to build large system models.
    ocdRuntimeSpec: {
        ____label: "OCD Runtime Filter Spec",
        ____description: "OCP constructor synthesizes the OCD runtime spec from the dev-defined OCD template spec, its specific OPM bindings, and the set of registered OPM instances passed to the constructor.",
        ____accept: "jsObject" // You can't filter a filter spec w/a filter spec. But you can accept an opaque object and validate the incoming spec by building a filter which is what we do here.
    },

    // Created by ocp constructor filter. This object represents the runtime state of the hierarchical system of OPM managed by this OCP instance.
    ocdi: {
        ____label: "OCD Runtime Instance",
        ____description: "OPC instance's contained OCD shared process data runtime store. This is an instance of ObservableControllerData ES6 class constrained by ocdRuntimeSpec, and initialized w/ocdInitData.",
        ____accept: "jsObject" // We do not validate ES6 classes w/filter. They're designed to be valid by construction. Or, in zombie state.
    },

    transitionDispatcher: { ____accept: "jsObject" },

    actionDispatcher: { ____accept: "jsObject" },

    evalCount: { ____accept: "jsNumber", ____defaultValue: 0 },

    lastEvalResponse: { ____accept: [ "jsObject", "jsNull" ], ____defaultValue: null },

    opcActorStack: { ____accept: "jsArray", ____defaultValue: [] }

};
