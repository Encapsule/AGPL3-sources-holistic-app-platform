// gulpfile.js

const arccore = require('arccore');
const process = require('process');
const gulp = require('gulp');
const gulpRename = require('gulp-rename');
const gulpUtil = require('gulp-util');
const gulpUglify = require('gulp-uglify');
const zip = require('gulp-zip');
const fs = require('fs');
const path = require('path');
const del = require('del');
const mkdirp = require('mkdirp');
const webpack = require('webpack');
const gulpHelpTask = require('./gulptasks/gulp-help-task');
const childProcess = require('child_process');
const webpackClientConfig = require('./webpack-config-client');
const webpackServerConfig = require('./webpack-config-server');
const handlebars = require('handlebars');

gulp.task("help", gulpHelpTask);

const projectRootDirectory = path.normalize(path.join(__dirname, '../../../..'));
const packageMeta = require(path.join(projectRootDirectory, 'package.json'));
const basePackageMeta = require('../../package.json');

// Extract command line option(s).

var targetBuildEnvironment = null;
var i = process.argv.indexOf('--env');
if (i < 0) {
    throw new Error("Sorry - you need to define the build's target deployment environment via the `--env envName` command line option.");
}
if (i > 0 && ((process.argv.length - i) > 1)) {
    targetBuildEnvironment = process.argv[i+1];
} else {
    throw new Error("Unable to determine the build's target deployment environment from command line option `--env`. Check command syntax.");
}

// Load the derived application's build config manifest.

const derivedAppConfigPath = path.join(projectRootDirectory, "sources/build/app-config");
const appConfigRaw = require(derivedAppConfigPath);

const appConfigFilter = require('./app-config-filter');
var appConfigFilterResponse = appConfigFilter.request(appConfigRaw);
if (appConfigFilterResponse.error) {
    // The derived application configuration manifest cannot be parsed.
    throw new Error([
        "We cannot parse your derived application's build configuration module!",
        "Attempting to load config manifest '" + derivedAppConfigPath + "'",
        appConfigFilterResponse.error
    ].join(' '));
} // if appConfigFilterResponse.error
const appConfig = appConfigFilterResponse.result;


if (packageMeta.codename !== basePackageMeta.codename) {
    console.log("**************************************************************************");
    console.log("RAINIER-UX / RAINIER-UX-BASE VERSION MISMATCH ERROR.");
    console.log("rainier-ux/package.json depends on rainier-ux-base codename '" + packageMeta.codename + "'.");
    console.log("But, the installed version of rainier-ux-base package is codename '" + basePackageMeta.codename + "'.");
    console.log("In order to get a valid build, rainier-ux's dependency on rainier-ux-base codename '" + packageMeta.codename + "' must be met.");
    console.log("\n");
    console.log("If this error occurs in a test or deploy job please ensure that rainier-ux/package.json `codename` is set correctly.");
    console.log("If this error occurs in development, check node_modules/rainier-ux-base/package.json version. And, resynchronize as necessary.");
    console.log("**************************************************************************");
    throw new Error("Invalid package dependency configuration. Application and rainier-ux-base package codenames.");
}

gulp.task('build:tag', [ 'clean' ], function(cb_) {
    console.log("Generating build tag: build metadata (git commit hash, version, etc ...)");

    const commitHash = childProcess.execSync('git rev-parse HEAD', { cwd: projectRootDirectory }).toString().trim();
    const commitHashShort = childProcess.execSync('git rev-parse --short HEAD', { cwd: projectRootDirectory }).toString().trim();
    const buildTimestamp = (new Date()).toISOString();
    const buildID = arccore.identifier.hash.toIRUT(arccore.identifier.hash.fromUTF8(buildTimestamp + commitHash));

    // We should extend this pattern for communicating flags and keys by command line option when extending rux and
    // the rainier-ux-base build system over time in order to avoid using the environment block for this purpose.
    // Environment block should only be used to configure or override the software default behavior of the application
    // at runtime.

    // Dereference the appConfig declaration to obtain target deployment config declarations.
    const targetBuildDeploymentData = appConfig.derivedAppConfigManifest.aspects.deployment.environments[targetBuildEnvironment];

    if (!targetBuildDeploymentData) {
        throw new Error("No way man!");
    }

    console.log(JSON.stringify(targetBuildDeploymentData));

    console.log("**** TARGET ENVIRONMENT: " + targetBuildEnvironment);

    const javascriptModule = [ '// _build-tag.js',
                               '// This file is generated by the RAINIER-ux-base package\'s build system',
                               '// under the control of your application package\'s local rux script.',
                               '// Reported git commit hash is the last commit of your application package.',
                               '// Reported build timestamps are set during the build process.',
                               '// buildID is a 32-bit Murmur3 digest hash of commit hash and build timestamp.',
                               '// It is used as the last identifier in a release zip filename to aid in tracking',
                               '// specific releases built against a specific commit hash.',
                               'module.exports = {',
                               '    buildTimestamp: \'' + buildTimestamp + '\',',
                               '    buildCommitHash: \'' + commitHash + '\',',
                               '    buildCommitShortHash: \'' + commitHashShort + '\',',
                               '    buildID: \'' + buildID + '\',',
                               '    buildConfig: {',
                               '        deployConfig: {',
                               '            appDeployEnvironment: \'' + targetBuildEnvironment + '\',',
                               '            appBaseUrl: \'' + targetBuildDeploymentData.appBaseUrl + '\',',
                               '            appBasePath: \'' + targetBuildDeploymentData.appBasePath + '\',',
                               '            appAuthDisabled: ' + targetBuildDeploymentData.appAuthDisabled,
                               '        }',
                               '    },',
                               '    displayName: \'' + packageMeta.displayName + '\',',
                               '    packageName: \'' + packageMeta.name + '\',',
                               '    packageDescription: \'' + packageMeta.description + '\',',
                               '    packageVersion: \'' + packageMeta.version + '\',',
                               '    packageCodename: \'' + packageMeta.codename + '\',', // never omit - used to version rainier-ux-base
                               '    packageAuthor: \'' + packageMeta.author.name + '\',',
                               '    environment: \'' + targetBuildEnvironment + '\',',
                               '};'
                             ].join('\n');

    const targetDirectory = path.join(projectRootDirectory, 'build');
    const targetFilenameBuildTag = path.join(targetDirectory, '_build-tag.js');
    mkdirp(targetDirectory);
    fs.writeFileSync(targetFilenameBuildTag, javascriptModule);
    console.log("Wrote '" + targetFilenameBuildTag + "'...");

    const versionDash = packageMeta.version.split('.').join('_');

    const releasePackageManifest = {
        private: true,
        name: packageMeta.name + "_release_" + versionDash + "_" + packageMeta.codename + "_" + commitHashShort + "_" + buildID,
        version: packageMeta.version,
        codename: packageMeta.codename,
        buildID: buildID,
        buildCommitHash: commitHash,
        buildTimestamp: buildTimestamp,
        description: packageMeta.description,
        author: {
            name: packageMeta.author.name
        },
        license: "UNLICENSED",
        scripts: {
            start: "node server-app-bundle.js"
        }
    };

    const releasePackageManifestJSON = JSON.stringify(releasePackageManifest, undefined, 2);
    const targetFilenamePackageManifest = path.join(targetDirectory, 'package.json');
    fs.writeFileSync(targetFilenamePackageManifest, releasePackageManifestJSON);
    console.log("Wrote '" + targetFilenamePackageManifest + "'...");
    console.log("> Generated package.json for final bundled release image: '" + JSON.stringify(releasePackageManifest) + "'");

    cb_();
});




// ----------------------------------------------------------------------
// clean (delete) the output of the build process
// ----------------------------------------------------------------------
// This turned out to be a larger PITA than expected.
// gulp seeming forces a developer to demote common dependencies to leaf nodes.
// you see if the order in which dependencies are specified is not considered,
// then there's no other way. Sad...

gulp.task("clean", function(cb_) {
    del([ path.join(projectRootDirectory, 'build', '**') ], { force: true } ).then(function(pathnames_) {
        if (pathnames_.length)
            console.log('./build CLEANED (removed):\n' + pathnames_.map(function(line_) { return "[x] " + line_; }).join('\n'));
        else
            console.log('Build is already clean!');
        del([ path.join(projectRootDirectory, 'stage', '**') ], { force: true } ).then(function(pathnames_) {
            if (pathnames_.length)
                console.log('./stage CLEANED (removed):\n' + pathnames_.map(function(line_) { return "[x] " + line_; }).join('\n'));
            else
                console.log('Stage is already clean!');

            cb_();
        });
    });
});

// ----------------------------------------------------------------------
// webpack task - transform various JavaScripts to JavaScript
// ----------------------------------------------------------------------
// This gulp task takes an external dependency on the webpack configuration module ./webpack_dev_server.js
gulp.task("webpack:server", [ 'build:tag' ], function(cbTaskComplete_) {
    var webpackCompiler = webpack(webpackServerConfig);
    webpackCompiler.run(function(error_, stats_) {
	if (error_) {
	    throw new gulpUtil.PluginError({ plugin: "webpack:server", message: error_.toString() });
    }

    gulpUtil.log("webpack:server", stats_.toString({colors: true}));
        if (stats_.compilation.errors.length) {
            throw new gulpUtil.PluginError({ plugin: "webpack:server ", message: JSON.stringify(stats_.errors) });
        }
	cbTaskComplete_();
    });
});

// This gulp task takes an external dependency on the webpack configuration module ./webpack_dev_client.js
gulp.task("webpack:client", [ 'build:tag' ], function(cbTaskComplete_) {
    var webpackCompiler = webpack(webpackClientConfig);
    webpackCompiler.run(function(error_, stats_) {
	if (error_) {
	    throw new gulpUtil.PluginError({ plugin: "webpack:client ", message: error_.toString() });
	}
	gulpUtil.log("webpack:client", stats_.toString({colors: true}));
        if (stats_.compilation.errors.length) {
            throw new gulpUtil.PluginError({ plugin: "webpack:client ", message: JSON.stringify(stats_.errors) });
        }
	cbTaskComplete_();
    });
});


// ----------------------------------------------------------------------
// Build resources
// ----------------------------------------------------------------------
gulp.task("build:resources", [ 'build:resources:css', 'build:resources:images', 'build:resources:fonts', 'build:resources:icons', 'build:resources:html', 'build:resources:app' ], function() {
    console.log("build:resources task complete.");
});

gulp.task("build:resources:css", [ 'build:tag' ], function() {
    return gulp.src('../resources/css/*.css').pipe(gulp.dest('../../../../build/_resources/css/'));
});

gulp.task("build:resources:images", [ 'build:tag' ], function() {
    return gulp.src('../resources/images/**').pipe(gulp.dest('../../../../build/_resources/images/'));
});

gulp.task("build:resources:fonts", [ 'build:tag' ], function() {
    return gulp.src('../resources/fonts/**').pipe(gulp.dest('../../../../build/_resources/fonts/'));
});

gulp.task("build:resources:icons", [ 'build:tag' ], function() {
    return gulp.src('../resources/icons/**').pipe(gulp.dest('../../../../build/_resources/icons/'));
});

gulp.task("build:resources:html", [ 'build:tag' ], function() {
    return gulp.src('../resources/html/**').pipe(gulp.dest('../../../../build/_resources/html/'));
});


gulp.task("build:resources:app", [ 'build:tag' ], function() {
    return gulp.src('../../../../sources/resources/**').pipe(gulp.dest('../../../../build/_resources/'));
});


// ----------------------------------------------------------------------
// Build the server half of the application
// ----------------------------------------------------------------------
gulp.task('build:server', [ 'webpack:server' ], function() {
    console.log("build:server task complete.");
});

gulp.task("build:ebextension", [ 'build:ebextension:copy', 'build:ebextension:sumologic' ], function() {
    console.log("Ebextension task complete");
});

gulp.task("build:ebextension:copy", [ 'build:tag' ], function(){
    return gulp.src(['../server/aws/ebextensions/**']).pipe(gulp.dest('../../../../build/.ebextensions/'));
});

gulp.task("build:ebextension:sumologic", ['build:tag', 'build:ebextension:copy' ], function(){
    // process ebextension templates
    const buildDirectory = path.normalize(path.join(projectRootDirectory, 'build'));
    const buildTag = require(path.join(buildDirectory, '_build-tag'));
    const outputPath = path.join(buildDirectory, '.ebextensions');
    // generate the actual config for sumologic
    
    const sumologicFilePath = path.join('../server/aws/templates/89_sumologic.config.hbs');
    var fileContent = fs.readFileSync(sumologicFilePath, "utf8");    
    var sumologicHandlebar = handlebars.compile(fileContent);
    var parsedSumologicFile = sumologicHandlebar(buildTag);
    return fs.writeFileSync(path.join(outputPath,'89_sumologic.config'), parsedSumologicFile);
});

// ----------------------------------------------------------------------
// Build the client half of the application
// ----------------------------------------------------------------------
gulp.task("build:client", [ 'webpack:client' ], function() {
    console.log("build:client task complete.");
});

// ----------------------------------------------------------------------
// Build the application
// ----------------------------------------------------------------------
gulp.task('build', [ 'build:server', 'build:client', 'build:resources' ], function() {
    console.log("build task complete.");
} );

gulp.task('stage', [ 'build' ], function() {
    var buildPath = path.join(projectRootDirectory, 'build');
    console.log("Starting deployment task ... ");
    return gulp.src([path.join(buildPath, '**'), path.join(buildPath, '.**', '**')]).pipe(gulp.dest(path.join(projectRootDirectory, 'stage')));
});

// TODO: Not currently called
gulp.task('stage:compress', function() {
    gulp.src('./index.js').pipe(gulpUglify).pipe(gulp.dest('min.js'));
});

gulp.task('start', [ 'stage' ], function() {
    console.log("Starting application server...");
    // Start the Node.js application server on localhost.
    // Blocks the main rux thread on network socket.
    // CTRL-C at the console to shut the server down.
    // Or, use `rux debug` to launch the server under the Node.js debugger.
    require(path.join(projectRootDirectory, 'stage/server-app-bundle'));
});



// Create a zipfile of the stage directory. Place the zip in the dist directory.

gulp.task('release', [ 'build:ebextension', 'stage' ], function (cb_) {
    const archiveDestinationDirectory = path.join(projectRootDirectory, 'target/release/');
    mkdirp(archiveDestinationDirectory);
    const archiveSourceDirectory = path.normalize(path.join(projectRootDirectory, 'stage'));
    const buildTagFullpath = path.join(archiveSourceDirectory, '_build-tag');
    const buildTag = require(buildTagFullpath);
    console.log(JSON.stringify(buildTag));
    const archiveFilename = [
        buildTag.packageAuthor,
        buildTag.packageName,
        ('v' + buildTag.packageVersion),
        buildTag.buildCommitShortHash,
        buildTag.buildID,
        targetBuildEnvironment
    ].join('_') + '.zip';
    const archiveFullpath = path.join(archiveDestinationDirectory, archiveFilename);
const zipCommand = 'zip -r ' + archiveFullpath + ' .';
    const zipResult = childProcess.execSync(zipCommand, { cwd: archiveSourceDirectory, stdio: [0,1,2] });
    console.log("Wrote '" + archiveFullpath + "'.");
    cb_();
});



gulp.task('default', [ 'start' ], function() {
    console.log("default task complete.");
});

